#!/usr/bin/env python

"""countloc

Given a search pattern, compute the number of Lines of Code
for each file found.
"""

import os
import re
import os.path
import optparse
from fnmatch import fnmatch
from os.path import isfile

"""Math Tools

Module of small useful math tools aka common math routines.
"""

from math import sqrt

def mean(xs):
    """Calculate the mean of a list of numbers given by xs"""

    return sum(xs) / len(xs)

def std(xs):
    """Calculate the standard deviation of a list of numbers give by xs"""

    m = mean(xs)
    dxs = (x - m for x in xs)
    qdxs = (x * x for x in dxs)
    s = l = 0
    for i in qdxs:
        s += i
        l += 1
    return sqrt(s / (l - 1))


def getFiles(root, pattern=".*", tests=[isfile], **kwargs):
    """getFiles(root, pattern=".*", tests=[isfile], **kwargs) -> list of files

    Return a list of files in the specified path (root)
    applying the predicates listed in tests returning
    only the files that match the pattern. Some optional
    kwargs can be specified:

    * full=True        (Return full paths)
    * recursive=True   (Recursive mode)
    """

    def test(file, tests):
        for test in tests:
            if not test(file):
                return False
        return True

    full = kwargs.get("full", False)
    recursive = kwargs.get("recursive", False)

    files = []

    for file in os.listdir(root):
        path = os.path.abspath(os.path.join(root, file))
        if os.path.isdir(path):
            if recursive:
                files.extend(getFiles(path, pattern, tests, **kwargs))
        elif test(path, tests) and re.match(pattern, path):
            if full:
                files.append(path)
            else:
                files.append(file)

    return files

__version__ = "0.4"
__copyright__ = "CopyRight (C) 2008-2014 by James Mills"
__author__ = "James Mills, prologic at shortcircuit dot net dot au"
__url__ = "http://prologic.shortcircuit.net.au/"

USAGE = "%prog [options] <pattern>"
VERSION = "%prog v" + __version__

def parse_options():
    """parse_options() -> opts, args

    Parse and command-line options given returning both
    the parsed options and arguments.
    """

    parser = optparse.OptionParser(usage=USAGE, version=VERSION)

    parser.add_option("-v", "--verbose",
            action="store_true", default=False, dest="verbose",
            help="Verbose output during operation.")
    parser.add_option("-I", "--ignore",
            action="append", default=None, dest="ignore",
            help="List of glob patterns to ignore")
    parser.add_option("-p", "--path",
            action="store", default=".", dest="path",
            help="Set path to search.")
    parser.add_option("-t", "--total",
            action="store_true", default=False, dest="total",
            help="Display total Lines of Code only.")
    parser.add_option("-s", "--stats",
            action="store_true", default=False, dest="stats",
            help="Display file statistics and total Lines of Code.")
    parser.add_option("-r", "--recursive",
            action="store_true", default=False, dest="recursive",
            help="Recursive mode")

    opts, args = parser.parse_args()
    if len(args) < 1:
        parser.print_help()
        raise SystemExit(1)

    return opts, args

def getLOC(path):
    with open(path) as f:
        return len(f.readlines())

def main():
    opts, args = parse_options()

    cwd = os.getcwd()
    path = opts.path
    pattern = args[0]

    if path == ".":
        path = os.getcwd()

    def ignore(filename):
        for ignore in (opts.ignore or []):
            if fnmatch(filename, ignore):
                return False
        return True

    files = getFiles(
        path, pattern, tests=[ignore], recursive=opts.recursive, full=True
    )

    total = 0
    locs = []
    for file in files:
        loc = getLOC(file)
        total += loc
        locs.append(loc)
        if opts.verbose:
            filename = file.replace(cwd, ".")
            print "%s: %d" % (filename, loc)

    if opts.verbose:
        print

    if opts.total:
        print "Files:    %d" % len(locs)
        print "Total:    %d" % total

    if opts.stats:
        print "Min:      %d" % int(min(locs))
        print "Mean:     %d" % int(mean(locs))
        print "Max;      %d" % int(max(locs))
        print "Std Dev.: %d" % int(std(locs))


if __name__ == "__main__":
    main()
